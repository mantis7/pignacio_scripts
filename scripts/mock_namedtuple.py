#! /usr/bin/env python
# -*- coding: utf-8 -*-
from __future__ import absolute_import, unicode_literals

import collections
import logging


logger = logging.getLogger(__name__)  # pylint: disable=invalid-name


class UnmockedField(Exception):
    """ Exception for errors generated by missing mock fields. """

    def __init__(self, clz, field, message=None):
        """
        :clz: namedtuple class
        :field: missing field
        :message: optional exception message
        """
        Exception.__init__(self)

        self._clz = clz
        self._field = field
        self._message = message


def mock_namedtuple(tuple_class):
    class MockTuple(tuple_class):
        __EXCEPTION_SENTINEL = object()
        def __new__(cls, **kwargs):
            values = [kwargs.get(f, cls.__EXCEPTION_SENTINEL)
                      for f in tuple_class._fields]
            return tuple_class.__new__(cls, *values) #pylint: disable=star-args

        def __init__(self, **kwargs):
            for field in kwargs:
                if not field in self._fields:
                    raise ValueError("'{}' is not a valid field for {}".format(
                        field, tuple_class))
            kwargs = {f: kwargs.get(f, self.__EXCEPTION_SENTINEL)
                      for f in self._fields}
            tuple_class.__init__(self, **kwargs)

        def __getattribute__(self, attr):
            # Avoid recursion filtering _* lookups without doing self._* lookups
            value = tuple_class.__getattribute__(self, attr)
            if attr.startswith("_"):
                return value
            if value == self.__EXCEPTION_SENTINEL:
                raise UnmockedField(tuple_class, attr)
            return value


    return MockTuple
